#include <cmath>

#include "main.h"
#include "pads.h"

#include "fpga_mul.h"
#include "fpga_mul_test.hpp"

using namespace chibios_rt;

/*
 ******************************************************************************
 * DEFINES
 ******************************************************************************
 */

/*
 ******************************************************************************
 * EXTERNS
 ******************************************************************************
 */

/*
 ******************************************************************************
 * PROTOTYPES
 ******************************************************************************
 */

/*
 ******************************************************************************
 * GLOBAL VARIABLES
 ******************************************************************************
 */

double op0 = 3.71;
double op1 = 1.3;
volatile double result;
const double step = 0.13;
size_t wait_cycles = 0;
double delta;

/*
 ******************************************************************************
 ******************************************************************************
 * LOCAL FUNCTIONS
 ******************************************************************************
 ******************************************************************************
 */

/*
 ******************************************************************************
 * EXPORTED FUNCTIONS
 ******************************************************************************
 */

/**
 *
 */
void fpga_mul_test(MtrxMul *mulp) {

  double *ptr0 = mulMtrxSlice(mulp, 0);
  double *ptr1 = mulMtrxSlice(mulp, 1);
  double *ptr2 = mulMtrxSlice(mulp, 2);

  ptr0[0] = op0;
  ptr1[0] = op1;
  ptr2[0] = op0;

  result = op0 * op1;

  mulMtrxMultiply(mulp, 0, 1, 2, 10, 10);

  // collect result
  result = ptr2[0];

  delta = fabs(result - (op0*op1));
  if (delta > (double)0.0001) {
    red_led_on();
    green_led_off();
  }
  else {
    green_led_on();
    red_led_off();
  }

//  wait_cycles = 0;
//  op1 += step;
//  op2 += step + (double)0.0171;
//  if (op1 > 100)
//    op1 = -100;
//  if (op2 > 100)
//    op2 = -100;
}
